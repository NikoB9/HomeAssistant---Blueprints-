
blueprint:
  name: ZHA – IKEA STYRBAR – Contrôle lumière générique (appui court & long robustes)
  description: >
    Blueprint ZHA pour télécommande IKEA STYRBAR / TRÅDFRI.
    Gère appui court, appui long, arrêt appui long et variation température couleur (Kelvin).
  domain: automation

  input:
    remote_device:
      name: Télécommande IKEA (ZHA)
      selector:
        device:
          integration: zha

    light_target:
      name: Lumière ou groupe
      selector:
        entity:
          domain: light

    power_entity:
      name: Entité d’alimentation (optionnelle)
      default: ""
      selector:
        entity:
          domain:
            - light
            - switch

    brightness_step:
      name: Pas luminosité (%)
      default: 10
      selector:
        number:
          min: 1
          max: 50
          unit_of_measurement: "%"

    brightness_long_step:
      name: Pas luminosité appui long (%)
      default: 5
      selector:
        number:
          min: 1
          max: 20

    color_temp_kelvin_step:
      name: Pas de température (Kelvin)
      description: Pas fixe en Kelvin appliqué à chaque appui (ex. 250 K).
      default: 250
      selector:
        number:
          min: 50
          max: 2000
          step: 50
          unit_of_measurement: "K"

    long_press_max_repeats:
      name: Max répétitions appui long
      default: 50
      selector:
        number:
          min: 1
          max: 500

    long_press_interval:
      name: Intervalle appui long (s)
      default: 0.05
      selector:
        number:
          min: 0.05
          max: 1
          step: 0.05

mode: restart

trigger:
  - platform: event
    event_type: zha_event

action:
  - variables:
      # --- Données de l'événement ZHA ---
      device_id_remote: !input remote_device
      device_id_event: "{{ trigger.event.data.device_id }}"
      cmd: "{{ trigger.event.data.command }}"
      cid: "{{ trigger.event.data.cluster_id }}"
      args: "{{ trigger.event.data.args | default([]) }}"

      # --- Entrées du blueprint (mises ici -> résout des soucis de portée des !input) ---
      bri_step: !input brightness_step
      bri_long: !input brightness_long_step
      repeats: !input long_press_max_repeats
      interval: !input long_press_interval
      kelvin_step: !input color_temp_kelvin_step
      light: !input light_target
      power: !input power_entity

  # Filtrer uniquement la télécommande attendue
  - condition: template
    value_template: "{{ device_id_event == device_id_remote }}"

  # Allumer l'entité d'alimentation si spécifiée et éteinte (prise/switch amont)
  - if:
      - condition: template
        value_template: "{{ power != '' and is_state(power, 'off') }}"
    then:
      - service: "{{ power.split('.')[0] }}.turn_on"
        target:
          entity_id: "{{ power }}"

  # =========================
  # Appuis courts (luminosité)
  # =========================
  - choose:
      # Bouton haut court = on => +pas %
      - conditions: "{{ cid == 6 and cmd == 'on' }}"
        sequence:
          - service: light.turn_on
            target:
              entity_id: "{{ light }}"
            data:
              brightness_step_pct: "{{ bri_step }}"

      # Bouton bas court = off => -pas %
      - conditions: "{{ cid == 6 and cmd == 'off' }}"
        sequence:
          - service: light.turn_on
            target:
              entity_id: "{{ light }}"
            data:
              brightness_step_pct: "{{ -bri_step }}"

  # ===============================================
  # Appuis longs (variation continue de luminosité)
  # ===============================================
  - choose:
      - conditions: "{{ cid == 8 and cmd in ['move_with_on_off', 'move'] }}"
        sequence:
          - variables:
              # move_with_on_off = augmentation (↑), move = diminution (↓)
              direction: "{{ 0 if cmd == 'move_with_on_off' else 1 }}"
              continue_long_press: true
              count_repeat: 0
          - repeat:
              while: "{{ continue_long_press and count_repeat < repeats }}"
              sequence:
                - service: light.turn_on
                  target:
                    entity_id: "{{ light }}"
                  data:
                    brightness_step_pct: "{{ bri_long if direction == 0 else -bri_long }}"
                # On attend soit un 'stop', soit le timeout pour répéter
                - wait_for_trigger:
                    - platform: event
                      event_type: zha_event
                      event_data:
                        device_id: "{{ device_id_remote }}"
                  timeout: "{{ interval }}"
                - variables:
                    new_cmd: "{{ (wait.trigger.event.data.command if (wait is defined and wait.trigger is defined and wait.trigger is not none) else '') }}"
                    new_cid: "{{ (wait.trigger.event.data.cluster_id if (wait is defined and wait.trigger is defined and wait.trigger is not none) else none) }}"
                    count_repeat: "{{ count_repeat + 1 }}"
                - choose:
                    # Relâchement appui long => 'stop' sur cluster 0x0008
                    - conditions: "{{ new_cmd in ['stop','stop_with_on_off'] and new_cid == 8 }}"
                      sequence:
                        - variables:
                            continue_long_press: false

  # =================================================================
  # Température de couleur (gauche/droite) - 100% Kelvin, pas constant
  # =================================================================
  # - Agit uniquement si la (ou les) lumière(s) supporte(nt) la CT.
  # - Gauche (args[0]=257) => plus CHAUD => Kelvin diminue de kelvin_step
  # - Droite (args[0]=256) => plus FROID => Kelvin augmente de kelvin_step

  # Helpers : détection du support CT, bornes Kelvin, extraction arg
  - variables:
      # Si 'light' est un groupe, lire les attributs sur la première entité réelle
      _first_light: >-
        {% set entities = expand(light) if light is string else [] %}
        {% if entities|count > 0 %}
          {{ entities[0].entity_id }}
        {% else %}
          {{ light }}
        {% endif %}

      # Détection générique du support CT (Kelvin préféré, mireds en compat)
      _supported_modes: "{{ state_attr(_first_light, 'supported_color_modes') | default([], true) }}"
      _ct_supported: >-
        {{ 'color_temp_kelvin' in _supported_modes
           or 'color_temp' in _supported_modes
           or state_attr(_first_light,'min_mireds') is not none
           or state_attr(_first_light,'max_mireds') is not none }}

      # Bornes Kelvin (lecture directe si présentes, sinon conversion mireds)
      _min_k: >-
        {% set mk = state_attr(_first_light,'min_color_temp_kelvin') %}
        {% if mk is not none %}
          {{ mk|int }}
        {% else %}
          {% set mx = state_attr(_first_light,'max_mireds') | default(500, true) %}
          {{ (1000000 / (mx|float)) | round(0) | int }}
        {% endif %}
      _max_k: >-
        {% set mk = state_attr(_first_light,'max_color_temp_kelvin') %}
        {% if mk is not none %}
          {{ mk|int }}
        {% else %}
          {% set mn = state_attr(_first_light,'min_mireds') | default(153, true) %}
          {{ (1000000 / (mn|float)) | round(0) | int }}
        {% endif %}

      # Kelvin courant (direct si dispo, sinon conversion depuis mireds)
      _current_k: >-
        {% set ck = state_attr(_first_light,'color_temp_kelvin') %}
        {% if ck is not none %}
          {{ ck|int }}
        {% else %}
          {% set cm = state_attr(_first_light,'color_temp') %}
          {% if cm is not none %}
            {{ (1000000 / (cm|float)) | round(0) | int }}
          {% else %}
            {{ none }}
          {% endif %}
        {% endif %}

      # Normalisation du premier argument (liste ou mapping)
      first_arg: >-
        {% set a = args %}
        {% if a is sequence and a|length > 0 %}
          {{ a[0] }}
        {% elif a is mapping %}
          {{ a.get('0', a.get(0, a.get('param1', a.get('id', none)))) }}
        {% else %}
          {{ none }}
        {% endif %}

  # Si pas de support CT -> on ignore proprement
  - choose:
      - conditions: "{{ not _ct_supported }}"
        sequence:
          # Tu peux commenter ce log une fois que tout est OK
          - service: logbook.log
            data:
              name: "STYRBAR CT"
              message: "Ignoré (pas de support CT) — light={{ light }} first={{ _first_light }}"
              domain: automation

  # Sinon, traitement des appuis gauche/droite (cluster 0x0005 / 'press' / 257|256)
      - conditions: "{{ _ct_supported }}"
        sequence:
          # -------------------------
          # Bouton gauche = plus CHAUD (Kelvin ↓)
          # -------------------------
          - choose:
              - conditions: >-
                  {{ cid == 5 and cmd == 'press'
                     and first_arg is not none
                     and (first_arg == 257 or first_arg|string == '257') }}
                sequence:
                  - variables:
                      _base_k: "{{ (_current_k if _current_k is not none else _max_k) | int }}"
                      _next_k: "{{ [_base_k - kelvin_step, _min_k] | max }}"
                  # Tu peux commenter ce log une fois validé
                  - service: logbook.log
                    data:
                      name: "STYRBAR CT"
                      message: "Left (257) → K: {{ _base_k }} -> {{ _next_k }} (step={{ kelvin_step }}) bounds=[{{ _min_k }}, {{ _max_k }}]"
                      domain: automation
                  - service: light.turn_on
                    target:
                      entity_id: "{{ light }}"
                    data:
                      color_temp_kelvin: "{{ _next_k }}"

          # -------------------------
          # Bouton droit = plus FROID (Kelvin ↑)
          # -------------------------
          - choose:
              - conditions: >-
                  {{ cid == 5 and cmd == 'press'
                     and first_arg is not none
                     and (first_arg == 256 or first_arg|string == '256') }}
                sequence:
                  - variables:
                      _base_k: "{{ (_current_k if _current_k is not none else _min_k) | int }}"
                      _next_k: "{{ [_base_k + kelvin_step, _max_k] | min }}"
                  # Tu peux commenter ce log une fois validé
                  - service: logbook.log
                    data:
                      name: "STYRBAR CT"
                      message: "Right (256) → K: {{ _base_k }} -> {{ _next_k }} (step={{ kelvin_step }}) bounds=[{{ _min_k }}, {{ _max_k }}]"
                      domain: automation
                  - service: light.turn_on
                    target:
                      entity_id: "{{ light }}"
                    data:
                      color_temp_kelvin: "{{ _next_k }}"

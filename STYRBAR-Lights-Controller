
blueprint:
  name: ZHA – IKEA STYRBAR – Contrôle lumière générique (appui court & long robustes)
  description: >
    Blueprint ZHA pour télécommande IKEA STYRBAR / TRÅDFRI.
    Gère appui court, appui long, arrêt appui long et variation température couleur.
  domain: automation

  input:
    remote_device:
      name: Télécommande IKEA (ZHA)
      selector:
        device:
          integration: zha

    light_target:
      name: Lumière ou groupe
      selector:
        entity:
          domain: light

    power_entity:
      name: Entité d’alimentation (optionnelle)
      default: ""
      selector:
        entity:
          domain:
            - light
            - switch

    brightness_step:
      name: Pas luminosité (%)
      default: 10
      selector:
        number:
          min: 1
          max: 50
          unit_of_measurement: "%"

    brightness_long_step:
      name: Pas luminosité appui long (%)
      default: 5
      selector:
        number:
          min: 1
          max: 20

    color_temp_step:
      name: Pas température couleur (mireds)
      default: 40
      selector:
        number:
          min: 10
          max: 200

    long_press_max_repeats:
      name: Max répétitions appui long
      default: 50
      selector:
        number:
          min: 1
          max: 500

    long_press_interval:
      name: Intervalle appui long (s)
      default: 0.3
      selector:
        number:
          min: 0.05
          max: 1
          step: 0.05

mode: restart

trigger:
  - platform: event
    event_type: zha_event

action:
  - variables:
      device_id_remote: !input remote_device
      device_id_event: "{{ trigger.event.data.device_id }}"
      cmd: "{{ trigger.event.data.command }}"
      cid: "{{ trigger.event.data.cluster_id }}"
      args: "{{ trigger.event.data.args | default([]) }}"
      bri_step: !input brightness_step
      bri_long: !input brightness_long_step
      repeats: !input long_press_max_repeats
      interval: !input long_press_interval
      ct_step: !input color_temp_step
      light: !input light_target
      power: !input power_entity

  # Filtrer uniquement la télécommande attendue
  - condition: template
    value_template: "{{ device_id_event == device_id_remote }}"

  # Allumer l'entité d'alimentation si spécifiée et éteinte
  - if:
      - condition: template
        value_template: "{{ power != '' and is_state(power, 'off') }}"
    then:
      - service: "{{ power.split('.')[0] }}.turn_on"
        target:
          entity_id: "{{ power }}"

  # Gestion des appuis courts pour luminosité
  - choose:
      - conditions: "{{ cid == 6 and cmd == 'on' }}"
        sequence:
          - service: light.turn_on
            target:
              entity_id: "{{ light }}"
            data:
              brightness_step_pct: "{{ bri_step }}"

      - conditions: "{{ cid == 6 and cmd == 'off' }}"
        sequence:
          - service: light.turn_on
            target:
              entity_id: "{{ light }}"
            data:
              brightness_step_pct: "{{ -bri_step }}"

  # Gestion des appuis longs pour variation de luminosité (répétition jusqu'au relâchement)
  - choose:
      - conditions: "{{ cid == 8 and cmd in ['move_with_on_off', 'move'] }}"
        sequence:
          - variables:
              # move_with_on_off = augmentation (↑), move = diminution (↓)
              direction: "{{ 0 if cmd == 'move_with_on_off' else 1 }}"
              continue_long_press: true
              count_repeat: 0
          - repeat:
              while: "{{ continue_long_press and count_repeat < repeats }}"
              sequence:
                - service: light.turn_on
                  target:
                    entity_id: "{{ light }}"
                  data:
                    brightness_step_pct: "{{ bri_long if direction == 0 else -bri_long }}"
                # On attend soit un stop, soit le timeout pour faire un nouveau pas
                - wait_for_trigger:
                    - platform: event
                      event_type: zha_event
                      event_data:
                        device_id: "{{ device_id_remote }}"
                  timeout: "{{ interval }}"
                - variables:
                    new_cmd: "{{ (wait.trigger.event.data.command if (wait is defined and wait.trigger is defined and wait.trigger is not none) else '') }}"
                    new_cid: "{{ (wait.trigger.event.data.cluster_id if (wait is defined and wait.trigger is defined and wait.trigger is not none) else none) }}"
                    count_repeat: "{{ count_repeat + 1 }}"
                - choose:
                    # Relâchement appui long
                    - conditions: "{{ new_cmd in ['stop','stop_with_on_off'] and new_cid == 8 }}"
                      sequence:
                        - variables:
                            continue_long_press: false

  # =========================
  # Gestion de la température de couleur (gauche/droite)
  # =========================
  # Objectif : n'agir que si la (ou les) lumière(s) supporte(nt) la CT,
  #            sinon ignorer proprement sans erreur.

  # 1) Helpers pour détecter le support CT, même pour un groupe
  - variables:
      # Retourne la première entité "réelle" si c'est un groupe, sinon la cible elle-même
      _first_light: >-
        {% set entities = expand(light) if light is string else [] %}
        {% if entities|count > 0 %}
          {{ entities[0].entity_id }}
        {% else %}
          {{ light }}
        {% endif %}
      # Détection générique du support CT :
      #  - 'color_temp' dans supported_color_modes
      #  - ou présence de bornes min/max mireds
      _supported_color_modes: "{{ state_attr(_first_light, 'supported_color_modes') | default([], true) }}"
      _has_min: "{{ state_attr(_first_light, 'min_mireds') is not none }}"
      _has_max: "{{ state_attr(_first_light, 'max_mireds') is not none }}"
      _ct_supported: >-
        {{ 'color_temp' in _supported_color_modes
           or 'color_temp_kelvin' in _supported_color_modes
           or _has_min or _has_max }}

      # Normalise le 1er argument du zha_event (list ou mapping)
      first_arg: >-
        {% set a = args %}
        {% if a is sequence and a|length > 0 %}
          {{ a[0] }}
        {% elif a is mapping %}
          {{ a.get('0', a.get(0, a.get('param1', a.get('id', none)))) }}
        {% else %}
          {{ none }}
        {% endif %}

      # Bornes CT robustes (si non connues, on prend 153–500 mireds)
      _min_ct: "{{ (state_attr(_first_light, 'min_mireds') | default(153, true)) | int }}"
      _max_ct: "{{ (state_attr(_first_light, 'max_mireds') | default(500, true)) | int }}"

  # 2) Si la (ou les) lumière(s) ne supporte(nt) pas la CT → on ignore
  - choose:
      - conditions: "{{ not _ct_supported }}"
        sequence:
          # Pas de support température de couleur : on ne fait rien
          - delay: 0

  # 3) Sinon, on traite gauche/droite (cluster 0x0005 / press / 257|256)
      - conditions: >-
          {{ _ct_supported }}
        sequence:
          # -------------------------
          # Gauche = plus CHAUD (mireds +) -> 257
          # -------------------------
          - choose:
              - conditions: >-
                  {{ cid == 5 and cmd == 'press'
                     and first_arg is not none
                     and (first_arg == 257 or first_arg|string == '257') }}
                sequence:
                  - service: light.turn_on
                    target:
                      entity_id: "{{ light }}"
                    data:
                      color_temp: >-
                        {%- set current_ct = state_attr(_first_light, 'color_temp') -%}
                        {%- set base = (current_ct if current_ct is not none else _max_ct) | int -%}
                        {{ (base + ct_step) | min(_max_ct) }}

          # -------------------------
          # Droite = plus FROID (mireds -) -> 256
          # -------------------------
          - choose:
              - conditions: >-
                  {{ cid == 5 and cmd == 'press'
                     and first_arg is not none
                     and (first_arg == 256 or first_arg|string == '256') }}
                sequence:
                  - service: light.turn_on
                    target:
                      entity_id: "{{ light }}"
                    data:
                      color_temp: >-
                        {%- set current_ct = state_attr(_first_light, 'color_temp') -%}
                        {%- set base = (current_ct if current_ct is not none else _min_ct) | int -%}
                        {{ (base - ct_step) | max(_min_ct) }}
